# 백엔드 환경 및 툴 설정

## gradle

- 소프트웨어 대발 프로세스를 간소화 및 통합하는 빙드 자동화 툴이며, 프로젝슽 의존성을 관리하고 빌드 프로세스를 처리한다.
- Spring boot와 함께 메이븐(Maven)이라는 다른 트로젝트 관리 도구를 쓸 수도 있지만 가시성이 좋은 gradle을 선택했습니다.
- gradle의 구성은 프로젝트의 build.gradle 파일에서 수행. 이 파일은 프로젝트의 특정 요구사항에 맞게 사용자가 지정가능하며 소프트웨어 빌드, 테스트 및 배포와 같은 작업을 자동화하는 데 이용가능.
- 이상의 파일은 일반적으로 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임 워크 등 프로젝트의 의존성에 대한 정보를 포함(Lombok설치 같은 것)
- build.gradle 파일을 작성할 때 Kotlin 또는 Groovy 프로그래밍 언어를 사용 할 수 있는데, Groovy로 선택 했다.

### 일반적인 build.gradle 내부의 항복

1. 플러그인(plugins) : 플로그인 블록은 프로젝트에서 쓰이는 gralde 플러그인을 정의하는 곳이며 여기에 롬복 및 스프링부트 버전도 명시할 예정이다.
2. 리포지토리(repository) : 의존성을 해결하는데 쓰이는 의존성 리포지토리를 정의. 여기서는 gradle이 의존성을 가져오기 위해 Maven Central 리포지 토리 사용
3. 의존성(dependencies) : 프로젝트에서 이용되는 의존성 지정
4. 태스크(task) : 테스트 등의 빌드 프로세스의 일부인 태스크를 정의

### 스프링 이니셜라이저 활용

https://start.spring.io/

1. Spring Web : Web 개발 관련 설정을 default로 가지고있는 의존
2. Spring Boot Dev Tools : 자동 재시작 기능을 제공하는 의존성으로, 변경 내용을 저장할 때마다 자동으로 재시작 되어 갱신된다.

```java
package com.example.cardatabase;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {

    public static void main(String[] args) {
        SpringApplication.run(CardatabaseApplication.class, args);
    }

}
```

이상의 main에서 처음보는 에네테이션 `@SpringBootApplication`이 있다.  
여러 애너테이션의 조합으로 이루어진 것으로 필요한 부분들만 정리하도록 하겠습니다.

1. @EnableAutoConfiguration
    - 스프링 부트의 자동 구성을 활성화. 프로젝트가 의존성에 따라 자동으로 구성되는데, 예를 들어 spring-boot-startoe-web 의존성이 있는 경우 스프링 부트는 사용자가 웹 애플리케이션을 개불 중
      이라고 가정하고, 그에 따라 애플케이션을 알아서 설정해 줍니다.
2. @ComponentScan
    - 스프링 부트 컴포넌트 검색으로 애플리케이션의 모든 컴포넌트를 찾을수 있도록 함
3. @Configuration
    - Bean 정의를 제공하는 소스로 쓸 수 있는 클래스를 지정.

### Spring Boot Dev Tools

- 이상으 ㅣ의존성은 애플리케이션 개발 프로세스를 간략화 해주는 의존성으로, 가장 중요한 것 중 하나는 클래스 경로의 파일이 수정될 때마다 스프링 부트 애플리케이션을 자동으로 재시작해 준다는 거다.

### Logging / Problem-Solution

- 로깅은 애플리케이션의 흐름을 모니터링하는데 이용할 수 있고, 프로그램 코드의 예기치 않은 오류를 포착할 수 있는 좋은 방법 입니다. Spring Boot Starter 패키지에는 별도의 구성 없이 로깅에 이용할
  수 있는 LogBack이 있습니다.
- 로그백은 SLF4J(Spring Logging Facade For Java)를 기본 인터페이스로 사용한다.

```java
package com.example.cardatabase;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {
    private static final Logger logger = LoggerFactory.getLogger(CardatabaseApplication.class);


    public static void main(String[] args) {
        SpringApplication.run(CardatabaseApplication.class, args);
        logger.info("Application Started / 어플리케이션이 실행 되었습니다.!");
    }

}

```

이상에서 이제 주의할 점은 Logger 하나 import 할려고 해도 동일한 이름을 지닌 클래스 / 인터페이스가 많다는 점이다.  
그래서 import의 경로도 잘 확인해 주어야 한다.

logger.info() 메서드는 로그 메시지를 콘솔에 출력합니다.

그리고 로깅 수준에는 TRACE / DEBUG / INFO / WARN / ERROR / FATAL / OFF 의 7가지로 나뉜다.  
이를 application/properties 에서 설정 할 수 있습니다. 이는 resources 폴더 내에 있다.  
`logging.level.root=DEBUG`로 작성한다면, 로그수준이 DEBUG 및 그 이상(DEBUG / INFO / WARN / ERROR)에 해당하는 로그 메시지를 볼 수 있습니다.

그리고 만약 재시작 하게 된다면 TRACE 관련 메시지는 표시 되지 않는다. 별도로 지정하지 않은 default 로깅 수준은 INFO에 해당한다.

그리고 스프링부트의 기본 port 번호는 8080에 해당한다.

port 구성
Spring boot : 8080
MariaDB : 3306

# 의존성 주입(Dependency Injection)

## 정의

- 다른 객체에 의존하는 개체를 만들 수 있는 스프트웨어 개발 기법.
- 클래스 간의 상호작용을 도우면서 동시에 클래스를 독립적으로 유지
- 의존성 주입의 세 가지 클래스 유형
    1. 서비스(Service) : 클라이언트가 이용할 수 있는 클래스(의존성)
    2. 클라이언트(Client) : 의존성을 이용하는 클래스
    3. 주입기(Injection) : 의존성(서비스)을 의존 클래스(클라이언트)에 전다.

의존성 주입을 통해 클래스를 느슨하게 열결하는 것이 가능합니다. 즉, 클라이언트 의존성의 생성이 클라이언트의 작동과 분리되어 단위 테스트가 더 쉬워집니다.

```java
public class Car {
    private Owner owner;

    public Car() {
        owner = new Owner();
    }
}
```

이상의 코드는 클라이언트 클래스인 Car가 서비스 클래스(Owner)의 객체를 생성하기 때문에 의존성 주입이 없다.

```java
public class Car {
    private Owner owner;

    public Car(Owner owner) {
        this.owner = owner;
    }
}

public class CarMain {
    static void main() {
        Car car1 = new Car(new Owner());

        Owner owner2 = new Owner();
        Car car2 = new Car(owner2);
    }
}
```

이상의 코드는 서비스 객체가 클라이언트 클래스에서 직접 생성되지 않는다. 대신 클래스 생성자에 매개변수로 전달되는 예시이다.

여기서 client class가 Car이고 의존성에 해당하는 것이 Owner이다.  
또한 서비스 클래스는 추상 클래스일 수 도있다. 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고, 테스트 중에는 Mock을 이용할 수도 있다.

## 의존성 주입 유형

1. 생성자 주입: 의존성이 클라이언트 클래스 생성자에게 전달되는 방식. 생성자 주입의 예시는 Car코드에서 확인 가능하다. 생성자 주입은 필수 의존성에 이용하는 것이좋다. 의존성은 클래스 생성자를 이용하여 제공되며
   필수 의존성 없이는 객체를 생성할 수 없다.( 즉 매개변수 없이 생성이 불가능 하다는 의미다.)
2. 세터 주입 : 의존성이 세털르 통해 제공되는 방식입니다.

```java
public class Car {
    private Owner owner;

    public void setOwner(Owner owner) {
        this.owner = owner;
    }
}
```

이상의 세터 주입은 아무런 의존성이 없더라도 객체를 생성할 수 있기 때문에 더 유연합니다. 이 접근 방식은 선택적 의존성을 허용해 줍니다.

의존성 주입은 코드의 의존성을 줄이고 코드르 재사용하기 쉽게 만들어 줍니다.

## 스프링 부ㅡ에서의 의존성 주입이용

스프링 프레임워크에서 의존성 주입은 스프링 ApplicationContext를 통해 이루어진다. 이는 객체(빈:bean)와 객체의 의존성을 생성하고 관리하는 역할이다.

스프 부트 애플리케이션 클래스를 검색하여 특정 애너테이션(@Service / @Repository / @Controller 등)이 있는 클래스를 스프링 빈으로 등록합니다. 의존성을 주입하면 이러한 빈을 주입할 수
있습니다.

1. 생성자 주입
    - 생성자를 통해 의존성을 주입. 이 방법은 객체가 생성될 때 필요한 모든 의존성을 반드시 이용하게 하므로 가장 권장되는 방법이다. 가장 보편적인 상황은 특정 작업을 위해 DB에 대한 접근이 필요한 경우
      입ㄴ다. 스플이 부트에서는 이를 위해 repository 클래스를 이용합ㄴ디ㅏ.

```java
public class Car {
    private final CarRepository carRepository;

    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
    // DB상에서 CarRepository에 있는 모든 자동차 목록을 가져온다.
    carRepository.findAll(); // SELECT * FROM car
    carRepository.findOwners(); // SELECT owner FROM car
}
```

여기서 알아야하는 것은 메서드의 메서드명이 findAll();로 고정되어있다.

클래스에 생성자가 여러개 있는 경우 `@AutoWired` 애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의해야한다.

```java
public class Car {
    private final CarRepository carRepository;

    //의존성 주입에 이용하는 생성자
    @AutoWired
    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
    // DB상에서 CarRepository에 있는 모든 자동차 목록을 가져온다.
}
```

2. 세터 주입 : 의존성은 세터 메서드를 통해 주입된다. 세터 주입은 선택적 의존성이 있거나 런타임(프로그램이 실행 중)에 의존성을 수정하려는 경우에 유용하다.

```java

@Service
public class AppUserService {
    private AppUserRepository userRepository;

    @AutoWired
    public void setUserRepository(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }


}
```

3. 필드 주입 : 의존성을 필드에 직접 주입합니다. 가장 단순하긴 한데, 의존성을 사용할 수 없는 경우에 런타임 에러가 발생할 수 있고, 테스트를 위해서 모의 객체를 만드는게 아니라 글때 그때 새로운 객체가
   만들어지기 때문에 테스트하기 어렵다.

```java

@Service
public class CarDatabaseService implements CarService {

}

public class CarController {
    @Autowired
    private CarDatabaseService carDatabaseService;
}
```

# JPA를 이용한 데이터 베이스 생성 및 접근

스프링 부트와 JPA(jakartaPersistence API / Java Persistence API )  
Entity 클래스로 데이터베이스를 정의하는 방법을 학습 예정

H2 인메모리 데이터베이스라는 개념을 학습. 그리고 H2에서 MariaDB로 이동. 동시에 CRUD Repository를 생성 및 데이터베이스의 테이블과 엔티티 클래스의 관계에 대해 학습

## ORM / JPA / Hibernate 개념

ORM / JPA는 RDB를 처리하기 위해 소프트웨어 개발에서 널리 이용되는 기술로, 복잡한 SQL쿼리를 작성 할 필요 없이 Java 개발자에게 친숙한 객체 형태로 DB를 조작할 수 있다. ORM/ JPA는 SQL
코드 작성 및 디버깅에 소요되는 시간을 줄여준다.

대부분의 JPA 구현체들은 Java ENtity 클래ㅛ스를 바탕으로 DB의 스키마를 자동으로 생성할 수 있다.

1. ORM(Object Relational Mapping): 객체 지형 프로그래밍 패러다임을 이용한 DB를 가져오고 매핑 할 수 있는 기술. ORM은 데이터 베이스 구조보다는 객체지향 개념을 바탕에 두고 있어서
   Java 개발자가 굳이 SQL까지 배울 필요성을 줄여준다는 점에서 장접이 있다. 그리고 장점은 ORM으로 개발하게 되면 DB와는 독립적으로 구동되기 때믄에 개발자가 필요하는 DBMS가 무엇인지에 따라 달라지는
   SQL문에 대해 걱정할 필요가 없다.
2. JPA : Java 개발자를 위한 객체 - 관계형 매핑을 제공(ORM의 더 구체적인 방식이라 생각하면 된다.).JPA 엔티티는 데이터베이스 테이블의 구조를 나타내는 JAva 클래스에 해당한다.
3. Hibernate : 최근에 가장 인기있는 JPA 구현체이고, 스프링 부트에서 기본 구현체로 이용된다. 대규모 어플리 케이션에서도 자주 쓰인다.

## 엔티티 클래스(Entity)

JAP 에서 @Entity 애너테이션을 이용하는 Java 클래스로 표준 Java bean 명ㅁ여 규착도 따르고, 적절한 게터 / 세터 메서드도 가진다. 또 private로 설정한다.

애플리케이션이 초기화 될 때 클래스 이름으로 데이터 베이스의 테이블을 생서ㅗㅇ 합니다. 만약에 다른 이름으로 지정하고 싶으면 엔티팉 클래스에 @Table 애너테이션을 별개로 달 수 있는데, 이는 다룰 예정

그럼 알 수 있는거 ->

1. filed 명이 colum명이 된다.
2. class 명이 table명이 된다.

```java
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    runtimeOnly 'com.h2database:h2'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

}
```

```java

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String brand, model, color, registrationNumber;

    private int modelYear, price;
}
```

1. @Id : DB에서의 테이블의 Primary Key에 해당하는 filed에 달아주는 애너테이션이다.
2. @GeneratedValue : 데이터베이스가 자동으로 ID를 생성하도록 지정 (ID 값을 우기가 객체 생성할 때 일일히 넣지 않는다는 것을 의미 및 다른 키 생성 전략을 사용할 수 도 있다.). AUTO는
   JPA 공급자가 특정 데이터 베이스에 가장 적합한 전략을 선핵한다는 의미로 default값이다.
    - DB에서의 column 명은 기본적으로 클래스 필드 명명 규칙에 따라 규정됩니다. 그래서 다른 컬럼며으로 지정하고 싶다면 @Column 애너테이션을 사용하여 커스텀 가능하다

3. @Column : 컬럼명을 사용자화 / 컬럼의 길이 / 컬럼의 nullable의 여부 지정하는 것도 가능.

```java
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(name = "explanation", nullable = false, length = 512)
    private String description;
}
```

즉, Car 클래스의 Description 필드는 car 테이블에서는 explanation 이라는 컬럼명을 가지고, VARCHAR(512)로 데이터 길이가 지정되었으며, null 불가라는 의미를 지니게 됩니다.

```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:h2:mem:testdb
spring.jpa.show-sql=true
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
```

chrome에서
localhost:8080/h2-console

1. domain 패키지가 test내에 있었던 경우에는 실행 됐으나 sql문이 실행되지 않습니다.
2. application.properties에서 오타가 있거나 하는 문제 ex) sohw-sql , show-slq ... etc
    - 이상의 경우들에서 생기는 문제점은 실행은 된다 하지만 생각한 결과값이 콘손에 안나온다

## CRUD repository 생성

Spring Data JPA에는 CRUD 작업을 위한 CrudRepository라는 인터페이스가 있다. 해당 인터페이스는 엔티티 클래스에 CRUD 기능을 제공한다.

1. domain 패키지에 interface인 CarRepository 생성

```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

public interface CarRepository extends CrudRepository<Car, Long> {

}
```

CarRepository는 스프링부트 JPA의 CrudRepository 인터페이스를 바탕으로 확장된 클래스입니다. (상속받았으니까 부모 클래스의 필드/ 메서드를 사용할 수 있다. 근데 둘 다 인터페이스이기 때문에
추상 메서드들을 상속 받았다 볼수 있다.) 그리고 `<Car, Long>` 타입의 argument 는 Car 엔티티 클래스의 리포지토리이고, id 필드의 타입이 Long임을 명시했다. 이상으 ㅣ제네릭으로

CRUDRepository 인터페이스네는 당연히 추상 메서드들이 존재한다.

### CrudRepository

1. long count() - 엔티티 수를 반환
2. Iterable<T> findAll() - 지정한 타입의 모든 항복을 반환 - Read
3. Optional<T> findById(ID id) - 지정한 ID의 한 항목을 반환 - Read
4. void delete(T entity) - 엔티티 삭제 - Delete
5. void deleteAll() - 리포지토리 내의 모든 에티티를 삭제 - Delete
6. `<S extends T>` save(S entity) - 엔티티를 저장 -Create
7. `List<T>` saveAll(`Interable<S>` entities) - 여러 엔티티를 저장 -Create

method가 한 항목만 반환 할 때는 T 대신에 `Optional<T>`를 반환합니다. Optional 클래스는 Java 8 SE 에서 처음 도입된 타입으로, 값을 ㅂ포함하거나 포함하지 않느 ㄴ단일 값
컨테이너이다.( 특정 id값이 없는 경우에 보통 메서드 결과값이 오류로 발생하기 때무넹 이를 막는 용도로 Optional을 사용한다.) 값이 있으면 isPresent() 메서드가 true로 반환하고, 없으면
false로 반환한다. 그리고 값이 있을 때 get() 메서드를 통해 값을 얻는다.

해당 Optional을 사용하게 된면 NullPointerException 을 방지 할 수 있게 된다.

2. 이제 H2 인 메모리에 예제 데이터들을 집어 넣겠습니다. 인메모리 DB는 실행 될 때마다 DB를 새로 만들고, 종료될 때 삭제 하기 때문에 현재 h2-console에서 값을 입력해 봤자 껐따 키면 없어 진다.
   이를 방지하기 위해서 Springboot 프로젝트내에 예제 데이터를 집어 넣도록 할 것이다.

CommandLineRunner 인터페이스를 사용 -> 

```java
package com.example.cardatabase;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	}

    @Override
    public void run(String... args) throws Exception {

    }
}

```
다음, 새로운 Car 객체를 데이터베이스에 저장할 수 있도록 CarRepository를 main 클래스에 주입할 예정이다. 생성자 주입 개념을 통해서 CarRepository를 주입하겠습니다.

Spring Data Repository에 쿼리 정의하는 것도 가능 (SQL을 의하는게 아니지만, SQL로도 쓸수 는 있다.) 쿼리는 접수다 (prefix : findBy 등)로 시작해야하고, 그 다음에는 쿼리에 이용할 엔티팉 클래스 필드를 정의해야한다.

그러면 main에
```java
void main() {
    System.out.println(repository.findByBrand("Kia"));
}
```
라고 작성했을 경우 콘솔 창에
`[Car(id = 1, ...,)]`과 같은 형태로 나오게 된다.

CarRepository에 색상으로 자동차들을 검색할 수 있도록 메서드를 저으이하고 main에 white색을 호출하여 콘솔창에 표시하시오.

CarRepository에 연도로 자동차들을 검색할 수 있도록 메서드를 정의하고 main에 2024로 호출하여 콘솔창에 표시하시오

```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

import java.util.List;

public interface CarRepository extends CrudRepository <Car, Long> {
    //스프링 내장 메서드 사용
    List<Car> findByBrand(String brand);
    List<Car> findByColor(String color);
    List<Car> findByModelYear(int modelYear);
    List<Car> findByBrandAndModel(String brand, String model);
    List<Car> findByBrandOrColor(String brand, String color);

    List<Car> findByBrandOrderByModelYearAsc(String brand);
    
    
}

```
```java
@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
    // CommandLineRunner 의 추상 메서드인 run()을 구현
    @Override
    public void run(String... args) throws Exception {
        // 내부에서 CarRepository의 객체인 repository의 메서드를 호출할 겁니다.
        repository.save(new Car("Kia", "Seltos", "Chacol", "370SU5690", 2020, 30000000));
        repository.save(new Car("Hyundai", "Sonata", "White", "123456", 2025, 25000000));
        repository.save(new Car("Honda", "CR-V", "Black-White", "987654", 2024, 45000000));
        // testdb내의 Car 테이블 내에 3개의 row를 추가 하여 저장한다는 의미
        // java 기준으로는 객체 새개를 만들어서 저장

        // 모든 자동차를 가져와서 Console에 로깅
        for (Car car : repository.findAll()) {
            logger.info("brand : {}, model : {}",car.getBrand(),car.getModel());
        }
        System.out.println(repository.findByBrand("Kia"));
        System.out.println(repository.findByColor("White"));
        System.out.println(repository.findByModelYear(2024));
        System.out.println(repository.findByBrandOrColor("Kia", "Silver"));
        System.out.println(repository.findByBrandAndModel("Kia", "K5"));
        System.out.println(repository.findByBrandOrderByModelYearAsc("Hyundai"));
    }
}

```
```java
package com.example.cardatabase.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;

import java.util.List;


public interface CarRepository extends CrudRepository <Car, Long> {
    // 쿼리작성 에너테이션 사용
    @Query("select c from Car c where  c.brand = ?1")
    List<Car> findByBrand(String brand);
}

```

지금 확인하면 기존의 List만 작성한거랑 크게 차이가 없다. 그러면 어떨때 쓰냐 하면 복잡한 쿼리식이나, LIKE같은 고급 표현식을 사용할 때 적용할 수 있다.
우리가 처음 작성한거 기준이라면
```java
System.out.println(repository.findByBrand("Ki"));
```
같이 작성을 하면 되지 않는다. 하지만 쿼리를 LIKE를 사용해서 작성해 두면 나오게 된다.

```java
public interface CarRepository extends CrudRepository <Car, Long> {
    @Query("select c from Car c where  c.brand = ?1")
    List<Car> findByBrand(String brand);

    @Query("select c from Car c where c.brand like %?1")
    List<Car> findByBrandEndsWith(String brand);

    @Query("select c from Car c where c.brand like ?1%")
    List<Car> findByBrandStartsWith(String brand);
}

```
와 같이 실행할 수 있다.

Spring Data JPA에서는 CrudRepository로 부터 확장된 PagingAndSortingRepository도 있습니다. 이 인터페이스는 페이징 및 정렬을 통해 엔티티를 검색하는 메서드를 제공합니다. 이 경우 대규모 결과 집합에서 모든 데이터를 반환할 필요가 없기 때문에 데이터를 처리하기 적합합니다.

```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.PagingAndSortingRepository;

import java.util.List;

public interface CarRepository extends PagingAndSortingRepository<Car, Long> {

}

```

제공하는 메서드
1. Iterable<T> findAll(Sort sort) - 지정된 옵션으로 정렬된 모든 엔티티를 반환
2. Page<T> findAll(Pagable pagable) - 지정한 페이징 옵션으로 모든 엔티티를 반환

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N) 관계에 있는 owner라는 새 테이블을 만들고. 일대다 관계는 소유자가 한명이 자동차 여러 대를 가질 수 있지만, 한 자동차의 소유자는 한 명이라는 의미이다.

domain 패키지에 Owner이라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들어야 합니다. 그리고 OwnerRepository는 JpaRepository를 상속 받아야 한다.

