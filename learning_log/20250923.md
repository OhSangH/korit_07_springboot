- Entity 클래스의 경우에는 DB에서 table역할을 한다.
- Entity 클래스의 ield들은 column역할을 한다.
- JPA와 연동 되어 있기 때문에 필수적으로 기본 생성자를 요구한다.
- id 값을 AUTO로 잡아 놨기 때문에 (즉, 생성될 때 마다 하나씩 증가하도록 id값이 설정 되어있다)그래서 모든 매개변수가 필요한 @AllArgsConstructor를 사용하지 못한다.

Owner의 작성
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;


    private String firstName, lastName;


    public Owner() {
    }


    public Owner(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }


    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public Long getOwnerId() {
        return ownerId;
    }

    public void setOwnerId(Long ownerId) {
        this.ownerId = ownerId;
    }
}
```

Lombok 사용 버전
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Data
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private final String firstName, lastName;

}
```
- `@RequiredArgsConstructor`의 사용의 경우 final 을 사용할 경우 기본 생성자와 겹치기 때문에  `@NoArgsConstructor(force = true)`처럼 force = ture의 적용이 필요하다.
- `final`키워드 적용 대신 `@NonNull`의 애너테이션을 사용할 경우 기본 생성자와 충돌이 일어나지 않기 때문에 이쪽을 선호하는 편이다. 


## 테이블 간의 관계 추가
car 테이블과 일대다(1:N) 관계에 있는 owner라는 새 테이블을 만들고. 일대다 관계는 소유자가 한명이 자동차 여러 대를 가질 수 있지만, 한 자동차의 소유자는 한 명이라는 의미이다.  
domain 패키지에 Owner이라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들어야 합니다. 그리고 OwnerRepository는 JpaRepository를 상속 받아야 한다.

이상의 일대다 관계를 추가하려면 `@ManyToOne`과 `@OneToMany`의 애너테이션을 이용해야 합니다. 외래키를 포함한 Car 엔티티 클래스에서는 `@ManyToOne`을 사용할 것이다. 그리고 외래키를 추가 했기 때문에 필드 구성이 달라져야 한다.

그럼 DB적으로 봤을 때는 car  table에다가 외래키인 ownerId를 추가하는 개념이라고 볼 수 있기 때문에 Car entity class에는 Owner 관련 필드를 추가 하여야 한다. 새로 추가된 field에 대한 게터 세터도 추가야 하며, 모든 JOIN관계에서는 FetchType.LAZY를 이용하는게 좋다. 대다(toMany) 관계의 경우에는 FetchType.LAZY가 기본 값이므로 정의할 필요가 없지만 대일 관계의 경우에는 반드시 명시해 줘야한다.

### Fetch Type
- DB데이터를 검색하는 전략을 정의
- 속성값으로는 EAGER, LAZY가 존재
- EAGER : 즉시 검색
- LAZY : 지연 검색
예제에서는 지연 검색은 DB에서 소유자를 검색하면 필요할 때 해당 소유자와 연관된 모든 자동차를 검색한다는 의미입니다. 반명 즉시 검색은 해당 소유자의 모든 자동차를 즉시 검색합니다.


```java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.*;

import java.util.*;

@Entity
@Data
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    @NonNull
    private String firstName, lastName;

    // 소유자는 다수의 차들을 가징수 있기 때문에 Collections를 사용
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private List<Car> cars;

}
```
```java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.*;

@Data
@Entity
@NoArgsConstructor
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)     // DB에 있는 AUTO_INCREMENT와 동일 자동으로 1씩 증가하며 값을 부여
    private Long id;
    private String brand, model, color, registrationNumber;
    private int modelYear, price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner" )
    private Owner owner;

    public Owner getOwner() {
        return owner;
    }

    public void setOwner(Owner owner) {
        this.owner = owner;
    }

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }
}
```
이상에 코드에서 `@Data`를 달아둔 경우에 일부러 겹치지만 Owner와 관련된 Getter/Setter를 코드로 작성. 반면에 `@Getter,@Setter`를 명시해둔 Owner 클래스에는 cars 관련 Getter / Setter를  안 썻다. 프로젝트 실 진입 시에는 코드 작성 필요 없다.

Owner class의 `@oneToMany` 애너테이션에는 특성이 있습니다.
1. cascade 속성은 삭제 / 업데이트 시 연속 효과가 적용되는 방법을 지정합니다.
    - ALL로 설정하게 되면 모든 작업이 연속적으로 적용됩니다.
    - 예로 Owner를 삭제 하게 되면 그 소유자를 연결된 객체들도 모두 삭제된다.
2. mappedBy = "owner" 속성 설정 : Car 클래스 사이에 이 관계인 외래키인 owner 필드가 존재함을 명시함.

SQL을 배운 저희가 어색하게 느껴질 수 있는 것은 OwnerId 필드 하나만 가지고 와서 연결 짓는게 아니라 Owner 클래스를 통째로 들고와서 Car에 field로 삼는다.


## H2 -> MariaDB로 이식












