# MVC 패턴
- 정의 : 애플리케이션의 구조를 모델, 뷰, 컨트롤러라는 세 부분으로 분리하여 개발하는 방식

## MVC 패턴이란?
사용자 인터페이스를 갖춘 애플리케이션을 구조화하는 소프트웨어 디자인 패턴.  
이는 비지니스 로직(데이터처리), 사용자 인터페이스, 그리고 이 둘을 연결하는 제어 로직을 명확하게 분리하는 것을 목표로 합니다.
- MVC의 구성 요소
  - Model
    - 역할 : 데이터와 비지니스 로직을 담당. 애플리케이션이 '무엇을'하는지에 대한 핵심적인 부분. 데이터의 저장, 처리, 조회, 변경 등의 작업을 수행하며, 사용자에게 보여줄 데이터 자체를 담고 있음
    - SpringBoot 상에서의 형태 : Service 클래스, Repository(DAO) 클래스, 혹은데이터 객체(DTO 또는 Entity) 등이 해당
  - View
    - 역할 : 사용자에게 데이터를 시각적으로 보여주는 역할. 사용자의 입력(클릭, 폼 제출 등)을 받고, 그 결과를 화면에 렌더링함. '어떻게'보여줄지를 담당.
    - SpringBoot 상에서의 형태 : HTML / CSS / JS를 통해 구성된 페이들이며, SpringBoot에서는 주로 Thymeleaf JSP(Java Server Page) 등의 템플릿 엔진을 사용하거나, REST API의 경우에는 JSON/XML 등의 데이터 형식으로 응답한다.
  - Controller
    - 역할 : 사용자의 요청을 받아 처리하고, Model과 View를 연결하는 중재자 역할. 사용자가 '무멋을 할지'에 대한 요청을 분석하고, Model에게 필요한 작업을 지시한 후 , 결과를 바탕으로 적절한 View를 선택하여 사용자에게 응답.
    - SpringBoot 상에서의 형태 : `@Contrller, @RestController`애너테이션이 붙은 클래스. `@RequestMapping` 등으리 애너테이션으로 특정 URL 요청을 처리하는 메서드를 정의.

## Spring MVC의 동작 원리 (요청 처리 흐름)
SpringBoot 는 내부적으로 Spring MVC 프레임워크를 사용하여 MVC 패턴을 구현. 모든 요청을 처리하는 중앙 집중식 프론트 컨트롤러(Front Controller) 방식이 핵심  
DispatcherServlet(디스패처 서블릿) - Spring MVC의 Core
- 웹 애플리케이션으로 들어오는 모든 HTTP 요청을 가장 먼저 받아서 처리하는 프론트 컨트롤러 역항. SpringBoot 는 내장된 웹 서버 (보통은 아파치 톰캣)를 사용하며, 별도의 복잡한 설정 없어 DispatcherServlet이 자동을 설정됩니다.

- 요청 처리의 단계
  - 사용자가 웹 브라우저에서 특정 URL을 입력하거나 버튼을 클릭 할 때 (HTTP 요청 발생)부터 화면에 결과가 표시될 때 까지의 과정을 상세 설명 합니다.
    1. 요청 수신(Request Reception) : 사용자의 요청(예시: `GET /users/1`)이 `DispatcherServlet`으로 전달.
    2. 핸들러 매핑(Handler Mapping)
       - `DispatcherServlet`은 `Handler Mapping`에게 요청 URL을 처리할 적절한 Controller를 찾아달라고 요청.
       - `Handler Mapping`은 주로 `@Controller`클래스의 `@RequestMapping` 애너테이션을 확인해서 요청을 처리할 특정 메서드를 찾게 됨.
    3. Controller 실행 :
       - `DispatcherServlet`은 찾은 Controller의 메서드를 `HandlerAdapter`를 통해 실행.
       - Controller는 요청을 분석하여 (필요한 경우에) Service / Repository(Model) 계층에 데이터 처리를 요청
       - 예를 들어, 사용자 정보를 조회하는 요청이라면 Model 계츠에서 데이터베이스로부터 해당 정보를 가져오게 되겠네요(그런데 비밀번호는 안보여주겠네요 = entity의 field를 변집한 버전을 전달)
    4. ModelView 반환
       - Controller의 처리 결과를 담은 Model 데이터와 View의 논리적 이름을 포함하는 ModelAndView 객체 (또는  View 이름나, 또는 Model 데이터만)를 `DispatcherServlet`에게 return
    5. View 이름 해석 (View Resolution)
       - `DispatcherServlet`은 `ViewResolver`에게 View의 논리적 이름(예를 들어 "user-detail")을 전달하여 실제 렌더링을 담당할 View 객체를 찾도록 요청
    6. View 렌더링 및 응담 (View Rendering & Response)
       - `DispatcherServlet`는 최종적으로 View 객체에게 Model 데이터를 전달하고 렌더링을 요청합니다.
       - View는 모델 데이터를 사용하여 최종적인 HTML 응답 페이지를 생성하고, 이 응답은 `DispatcherServlet`을 거쳐 사용자(브라우저)에게 전송됩니다.
  
- 쉽게 설명하면 `GET users/1`이면 DB 상에서의 user_id가 1인 애의 데이터를 이용하여 HTML 문서를 만들고, 2라면 user_id가 2인 애의 데이터를 활용하여 HTML 문서를 만들어서 브라우저로 보여준다고 보시면 되겠습니다.

## SpringBoot 3.5.6에서의 MVC 특징 및 구현 예시
SpringBoot에서는 Spring MVC를 자동으로 처리해 주기 때문에 개발자는 핵심 로직에만 집중할 수 있습니다.(비지니스 로직만 신경쓰고 서버 설정같은거는 안해도 된다는 뜻이다.) 3.xx.xx버전은 자바 17을 기반으로 하고, 설정 간소화와 편의성이 더 늘었다.

-Controller 구현 예시
```java
@Controller     // 해당 클래스가 컨트롤러임은 선언
public class UserController {
    private final UserService userService; //모델 계층과의 상호작용을 위한 Service 주입 (Injection)
    
    // 생성자 주입
    public UserController(UserService userService){
        this.userService = userService;
    }
    
    // GET 요청으로 /users/123
    @GetMapping("/users/{userId}")
    public String getUserDetail(@PathVariable Long userId, Model model){
        // 1. Controller는 Model(Service)에 데이터 처리를 요청
        User user = userService.findUserById(userId);
        
        // 2. Controller는 Model 데이터를 View에 전달하기 위해 Model 객체를 담음
        model.addAttribute("user", user);
        model.addAttribute("pageTitle", "사용자 상세 정보");
        
        // 3. Controller는 View의 논리적 이름을 return
        // : (ViewResolver가 "user-detail"에 해당하는 템플릿을 찾음)
        return "user-detail";
    }
}
```
이상의 코드는 Thymeleaf를 활용하여 SpringBoot와 HTML 문서를 연결하는 방식으로 저희가 받은 교재 중에 하나인 SpringBoot로 백엔드 개발자되기 책에도 동일한 방식의 코드 구현을 하고 있습니다.

- Model (Service 계층) 구현 예시
Controller의 요청을 받아서 실제 비지니스 로직을 처리하는 영역입니다.
```java
@Sevice
public class UserService{
    private final UserRepository userRepository;
    
    public userService(UserRepository userRepository){
        this.userRepository = userRepository;
    }
    
    public User findUserById(Long userId){
        User user = userRepository.findById(userId);
        if(id == user.getId()){
            return user;
        }
        return null;
    }
}
```
- 그 다음은 View 파트를 작성해야 하는데, Thymeleaf로 쓰는 예시를 굳이 할 필요는 없어 넘어간다.

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title th:text="${pageTitle}">사용자 상세</title> 
</head>
<body>
    <h1>사용자 상세 정보</h1>
    
    <p>ID: <span th:text="${user.id}">123</span></p>
    <p>이름: <span th:text="${user.name}">김철수</span></p>
    <p>이메일: <span th:text="${user.email}">chulsoo@email.com</span></p>
    
    <a href="/">돌아가기</a>
</body>
</html>
```
## MVC 패턴 사용의 장접
1. 관심사 분리 (Separation of Concerns) :
   - 데이터 처리(Model), 화면표시 (View), 요청처리 (Controller)가 명확하게 분리되어 있어, 각 부분을 독립적으로 개발하고 수정할 수 있다.
     - 보여주는 부분이 잘 못 됬다.-> View 수정
     - DB에서 가져오지를 못한다. -> Repository or Service 수정
     - 요청 엔드포인트가 잘못 됐다. -> Controller 수정 등
2. 높은 재사용성 :
   - 동일한 모델을 사용하여 여러 뷰(웹페이지, 모바일 앱, REST API 등)를 만들 수 있다.(대충 사이즈를 중여가지고 모바일 버전 웹 페이즈를 만든다든지, 회원 가입 창을 재활용해서 로그인 창으로 쓴다든지 등입니다.)
3. 유지 보수의 용이성:
   - 화면 디자인이 변경되어도 컨트롤러나 모델 코드는 거의 수정 할 필요가 없다. 
   - 이와 같이 로직이나 상호간의 변경이 끼치는 영향이 최소화 된다.
4. 테스트 용이성 :
   - 각 구성 요소가 독립적이기 때문에 단위 테스트를 쉽게 작성하고 수행할 수 있다. (GET 요청만 확인 한다던디 등) 특히 컨트롤러와 모델의 비지니스 로직은 뷰와 독립적으로 테스트가 가능하다.
5. 병렬 개발 가능 : 
   - 프론트엔드 개발자(뷰)와 백엔드 개발자(컨트롤러, 모델)가 서로의 작업에 크게 영향을 주지 않으며 동시에 개발이 가능해 속도가 향상합니다.

## 요약
1. MVC는 Model / View / Controller로 코드를 분리하는 디자인 패턴이다.
2. `DispatcherServlet`이라는 프론트 컨트롤러를 통하여 요청을 처리합니다.
3. Controller는 요청을 받고 Model을 호출하여 View를 선택하는 중재자 역할을 합니다.
   - View에서 요청(Request) -> Controller 내부의 코드에서 Service 호출 -> Service가 Repository를 호출하여 DB 관련 정보를 습득 후 데이터 처리 -> Controller로 보내주면 -> Controller가 적절한 .html 문서를 응답(Response). // ResponseEntity를 사용할 예정
4. Model은 비지니스 로직과 데이터를 담당(Entity - Repository - Service)

# 프로젝트 만든 후 실행 여부 시점을 기준
1. Car / CarRepository 제작
   - CarRepository 부분에서 JpaRepository를 상속 받으려고 하니 검색 안되어서 의존성 추가
   - Car의 필드에 Owner가 있는데 Owner엔티티 클래스가 없어서 에러 발생
2. Owner / OwnerRepository 생성
   - application.properties에 관련 설정을 안넣어서 실행할려니 안된다.
   - mariaDB관련 의존성도 추가
   - 이후 설정 완료 후 실행 시 DB 체크하면 엔티티 클래스에 넣었던 컬럼이 모두 생성된걸 확인 가능
   - Controller를 작성하지 않았기 때문에 HeidiSQL에서는 데이터를 확인 및 추가가 가능하지만 postman을 통해서는 불가능.
3. 이상의 과정에서 생긴 문제를 확인 CRUD를 하기 위해 MVC 패턴 생성필요
   - 루트 프로젝트에 service 패키지 생성 -> CarService 생성
4. 그러면 이제 페이지를 보여 줄 수 있도록 해야하는데, 이걸 React와 연결 할 예정이니 ResponseEntity와 연결하기 위해서 CarController를 제작
    ```java
    package com.example.cardatabase4.service;
    
    import com.example.cardatabase4.domain.Car;
    import com.example.cardatabase4.domain.CarRepository;
    import lombok.RequiredArgsConstructor;
    import org.springframework.stereotype.Service;
    
    import java.util.List;
    
    @Service
    @RequiredArgsConstructor
    public class CarService {
        private final CarRepository carRepository;
    
        public List<Car> getCars(){
            return carRepository.findAll();
        }
    
        //새로운 자동차 저장
        public Car addCar(Car car){
            return carRepository.save(car);
        }
    
    
    }
   ```
   service 정의
   ```java
    package com.example.cardatabase4.web;

    import com.example.cardatabase4.domain.Car;
    import com.example.cardatabase4.service.CarService;
    import lombok.RequiredArgsConstructor;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;
    
    import java.util.List;
    
    @RestController
    @RequestMapping("/api")
    @RequiredArgsConstructor
    public class CarController {
    private final CarService carService;
    
        // 1. 모든 차량 정보 조회
        @GetMapping("/cars")
        public List<Car> getCars(){
            return carService.getCars();
        }
    
        // 2. 차량 한대 추가
        @PostMapping("/cars")
        public ResponseEntity<Car> addCar(@RequestBody Car car){
            Car savedCar = carService.addCar(car);
            return new ResponseEntity<>(savedCar, HttpStatus.CREATED);
        }
    
    }
    ``` 
   정의한 service를 controller에서 사용하며 맵핑

# .map()
함수형 프로그래밍의 핵심 개념중 하나로, Collection이나 컨테이너 객체 내부의 각 요소를 반환 하여 새로운 컬렉션이나 컨테이너를 생성하는 데 사용한다.

## .map()의 전반적 정의
- 목적 : 컨테이너 객체 (예 : Stream, Optional)내부의 값을 다른 타입 또는 형태의 값으로 변환하여 새로운 컨테이너를 반환
- 각 element에 적용될 변환 함수(Function)을 argument로 받는다. -> 그래서 람다식이 필수적이다.
- 원본 데이터는 변경하지 않고 변환된 element를 담는 새로운 객체를 만드러 냅니다. (함수형 프로그래밍의 특징)

## .map()이 존재하는 주요 작료형 (Java 기준)
1. `Optional<T>` : 값이 있을 수도 있고 없을 수도 있는 단일 컨테이너
   - 역할 : 값이 존재할 경우에만 그 값을 반환하고, 그 결과를 다시 `Optional`로 감싸서 return. 값이 비어있는 경우에는 비어있는 Optional을 return
   - 예시 : `Optional<User>`를 `Optional<String>`으로 변환할 때 사용 등.
2. `Stream<T>` : 데이터소스(컬렉션, 배열 등)에서 element를 처리하기 위한 파이프라인을 구축하기 위해서 사용.
   - 역할 : Stream내의 모든 element에 대하여 argument로 들어온 변환 함수(람다식 형태)를 적용하여, 변환된 element를 담는 새로운 스트림을 생성
   - 예시 : `Stream<String>`(단어 목록)을 `Stream<Integer>`(각 단어의 길이)로 변환
3. Collection : List, Set 등의 자료구조
   - 역할 : 대부분의 객체 지향 언어에서 컬렉션이 자체적으로 .map()을 지원하는데, Java에서는 컬렉션을 직접 변환하기 위해 Stream을 거쳐야 한다.

## 예시
1. Stream에서 사용하기 (가장 흔함)

    ```java
    import java.util.stream.Collectors;
    
    public class StreamMapExample {
        static void main() {
            List<Integer> num = Arrays.asList(1, 2, 3, 4, 5);
    
            // 1. Stream 형태로 변환
            List<Integer> squaredNum = num.stream()
                    // 2. .map()으로 각 element(1,2,3,4,5)에 n * n을 하도록 내부에 람다식 적용
                    .map(n -> n * n)
                    // 3. 현재 stream이니까 다시 List로 바꿔줘야한다.
                    .collecion(Collectors.toList());
            System.out.println(squaredNum); // 결과값 : [1,4,9,16,25]
            System.out.println(num);        // 결과값 : [1,2,3,4,5]
        }
    }
    ```
2. Optional에서 사용하기(값의 안전한 접근 및 변환)  
    예를 들어 User 객체에서 이메이 주소만 가지고 오는데, User 객체가 존재만 하도록 도작

```java
import java.util.Optional;

class User {
    private String email;

    public User(String email) {
        this.email = email;
    }

    public String getEmail() {
        return this.email;
    }
}

public class OptionalMapExample {
    public static Optional<User> findUser(boolean found) {
        return found ? Optional.of(new User("Kim1@test.com")) : Optional.empty();
    }

    public static void main(String[] args) {
        String emailFound = findUser(true)
                .map(User :: getEmail)
                // 만약에 Optional<String>이 비어있으면 "N/A"를 반환하도록 작성
                .orElse("N/A");
        System.out.println("Email : " + emailFound);
        
    }
}

```
