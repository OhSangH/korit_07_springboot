# Spring Security 추가 정리
## 정의
- Spring 기반의 애플리케이션 보안(Authorization/ Authentication)을 위한 표준 프레임 워크. 서블릿 필터 (Servlet Filter) 체인을 기반으로 동작하며, 웹 요청에 대한 보안을 체계적으로 처리함. 단순한 로그인 기능 뿐만 아니라 CSRF, 공격방지, 세션 관리, 권한 기반 접근 제어 등 포괄적인 보안 기능을 제공.
## 특징
1. 포괄적 보안기능 :  인증(Authorization) / 인가(Authentication) 뿐 아니라 일반적인 웹 보안 위협으로 부터 애플리케이션을 보호
2. 유연한 설정 : Java 기반의 설정을 통해 유연하게 보안 정책을 설정할 수 있다.
3. 서블릿 필터 기반 : 요청이 컨트롤러에 도달하기 전에 여러 보안 필터를 거치게 하여 선제적인 보안 검사를 수행.
4. SpringBoot와의 통합 : `spring-boot-starter-security`의존성만 추가하면 기본적인 보안 기능이 자동 설정되어 빠르게 적용 가능(default 로그인 페이지, 패스워드 등)
## SecurityConfig
- Spring Security의 보안 구성(Config)을 담당하는 자바 설정 클래스로, 해당 클래스에는 `@Configuration, @EnableWebSecurity` 애너테이션을 추가하여 Spring Security의 보안 설정을 활성화 하고 커스터마이징을 할 수 있다.
- 과거에는 `WebSecurityCongurerAdapter`를 상속받아서 configure() 메서드를 오버라이딩하는 방식으로 사용했지만, SpringBoot 3.X 버전부터는 SecurityFilterChain 빈(bean)을 등록하는 방식이 권장됩니다. 현재의 방식은 컴포넌트 기반의 구성으로, 더욱 모듈화되고 유연한 보안 구성이 가능합니다.

## SecurityConfig의 핵심 역할
1. HTTP 요청에 대한 접근 제어 : 특정 URL 패턴에 대해 인증된 사용자만 접근을 허용하거나, 특정 권한(Role)을 가진 사용자만이 접근 가능하도록 설정 가능
2. 인증 방식 설정 : 폼 로그인, HTTP Basic 인증, OAuth2 로그인 등 다양한 인증 방식을 설정하고 커스터 마이징 가능
3. 로그아웃 처리 : 로그아웃 URL 및 로그아웃 성공 후 처리 로직을 정의
4. 비밀번호 암호화 : `PasswordEncoder`를 빈으로 등록하여 사용자의 비밀번호를 안전하게 암호화 하고 검증하는 방식을 지정
5. CSRF, CORS 설정 : CSRF 보호기능을 활성하 하거나 비활성화하고 , CORS 정책을 구성합니다.

### SecurityConfig 코드 예시
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig{
    // 비밀 번호 등록을 위한 PasswordEncoder 빈을 등록
    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCyptPasswordEncoder();
    }
    
    // Spring Security의 FilterChain을 작성
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception{
        http
            // 1. 인가(Authorization) 구성
            .authorizeHttpRequests(authorize -> authorize
                    .requestMatchers("/users/**").authenticated() // /users/** 경로는 인증된 사용자만 가능 -> 로그인만 되면 다 OK
                    .requestMatchers("/managers/**").hasAnyRole("ADMIN","MANAGER") // /managers/** 경로는 role이 ADMIN이거나 MANAGER인 사용자만 가능 -> Role이 해당 되면 OK
                    .requestMatchers("/admin/**").hasRole("ADMIN") // /admin/** 경로는 role이 ADMIN인 사용자만 가능 
                    .anyRequest().permitAll() // 나머지 경로에 대한 요청들은 접근을 허용함
            )
            // 2. 폼 로그인(Form Login) 구성
            .formLogin(form -> from
                    .loginPage("/login")    //커스텀 로그인 페이지의 URL을 지정
                    .loginProcessingUrl("/loginProc")   //로그인 처리 URL
                    .defaultSucessUrl("/")  //로그인 처리 후 URL
                    .permitAll()            //로그인 페이지는 모든 사용자가 접근 
            )
            // 3. 로그아웃 설정
            .logout(logout -> logout
                    .logoutUrl("/logout")   // 로그아웃 처리 URL
                    .logoutSuccessUrl("/")  // 로그아웃 성공 시 이동할 URL
                    .invalidateHttpSession(true)    // 세션 무효화
                    .deleteCoolies("JSESSIONID")       //쿠키 삭제 
            )
            // 4 CSRF 보호 비활성화(API 서버의 경우
            .csrf(csrf-> csrf.disable())
        ;
    }
}
```
- 이상의 코드의 상세 설명
  1. authorizeHttpRequests : HTTP 요청에 대한 인가 규칙을 구성
     - requestMatchers() : 특정 URL 패턴을 지정
     - authenticated() : 인증된 사용자만 접근 허용
     - hasAnyRole(),hasRole() : 특정 역할을 가진 사용자만 접근을 허용. Spring Security에서 역할(Role)은 기본적으로 "ROLE_"접두사가 붙어서 처리됩니다.(예시 : hasRole("ADMIN")은 "ROLE_ADMIN"역할을 확인한다는 의미입니다.)
     - permitAll() : 모든 사용자의 접근을 허용
     - anyRequest() : 위에서 설정한 규칙 외 모든 요청을 의미. 그래서 인가 규칙의 경우 구체적인 경로를 먼저 구성하고, 포괄적인 경로는 나중에 구성
  2. fromLogin : 폼 기반 로그인 설정
     - loginPage() : 기본 제공되는 로그인 페이지 대신 사용할 커스텀 로그인 페이지의 경로를 지정
     - loginProcessingUrl() : 로그인 폼 데이터를 처리할 URL을 지정. 이 URL에 대한 POST 요청을 Spring Security가 가로채서 인증을 처리
     - defaultSuccessUrl() : 로그인 성공 후 사용자를 리디렉션할 기본 페이지 설정.
  3. logout : 로그아웃 관련 설정
     - logoutUrl() : 로그아웃을 처리할 URL을 지정
     - logoutSuccessUrl() : 로그아웃 성공 후 리디렉션 될 페이지를 지정.
     - invalidateHttpSession(true) : 로그아웃 성공 시 HTTP 세션을 무효화
     - invalidateHttpCookie() : 로그아웃 시 쿠키를 무효화
     - deleteCoolies() : 쿠키를 삭제한다.
  4. csrf(csrf -> csrf.disable()) : CSRF 보호 기능을 비활성화. 

Java 관련 visual studio code Extension

Code Runner 
Debugger for Java
Extension Pack for Java

# 정리
AppUser // AppUserRepository를 생성 -> Spring Security의존성 도입 

이제 보안 관련 로직을 현재 프로젝트의 MVC 패턴에 맞게 설정할 필요가 있다.

1. 사용자 인증을 위한 Service 계층 구현 : Spring Security가 데이터베이스의 사용자 정보를 기반으로 인증을 수행할 수 있도록 UserDetailsService를 구현
   - service 패키지 내에 UserDetailsServiceImpl 클래스를 생성하고 UserDetailsService를 구현
       ```java
        @RequiredArgsConstructor
        public class UserDetailsServiceImpl implements UserDetailsService {
        private final AppUserRepository appUserRepository;
        
        
        
            @Override
            public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
                Optional<AppUser> user = appUserRepository.findByUsername();
        
                UserBuilder builder = null;
                if (user.isPresent()) {
                    AppUser currentUser = user.get();
                    builder = withUsername(currentUser.getUsername());
                    builder.password(currentUser.getPassword()).roles(currentUser.getRole());
                }
                else {
                    throw new UsernameNotFoundException(username);
                }
                return builder.build();
            }
        }
        
       ```
     이상의 코드는 cardatabase_2의 UserDetailsServiceImple과 코드라인이 일부 수정. 그 과정 중에서 AppUserRepository의 내부에 findByUserName(String username) 추상 메서드를 정의 했는데, 일반적인 방법으로 한 것이 아니라 오류를 발생시킨 다음에 intellij의 내부 기능을 사용하여 자동 생성 했다.  또한 User 클래스를 가지고 온 것이 아니라 static 메서드를 임포트하는 방식 코드라인 수정
2. jwt 토큰 생성 및 검증 Service 구현 : 로그인 성공 시에 JWT토큰을 발급하고, 이후의 모든 요청에 토큰을 검증하는 JwtService를 만든다.
   - 관련 의존성을 추가하고
   - service 패키지에 JwtService 클래스를 생성.

3. 로그인 Controller 및 관련 클래스 생성 : 로그인 요청 시에는 ID와 비밀번호를 담을 겁니다. 그러니깐 이게 꼭 AppUser Entity가 아니게죠. 그 때 우리는 뭘 새로 하나 만들었다.
   - domain 패키지 내에 AccountCredentials 레코드를 만드시오
   - web 패키지 내에 LoginController 클래스 작성
4. JWT 인증 필터 및 예외 처리 구현 : `/login`을 제외한 모든 API 요청을 가로채서 JWT 토큰의 유효성을 검사하는 Filter 제작
   - 루트 프로젝트 패키지에 AuthenticationFilter
5. AuthEntryPoint(인증 실패 처리) : 로그인 실패시에 현잳로라면 403이 떠야 합니다. 이를 401로 처리하기 위한 부분
   - 루트 프로젝트 패키지에 AuthEntryPoint 클래스 생성
6. SecurityConfig을 작성
   
7. 현재 AppUser를 객체 추가하려면 SQL문을 통하거나 혹은 CommandLineRunner를 통해서 생성. 이를 통해 생성된 AppUser객체를 가지고 로그인 성공 시 / 실패시를 확인하면 spring-data-rest 없는 상태의 부분이 구현

`@Service, @Conponent`의 차이 -> 컴포넌트 애너테이션은 bean등록을 위한 컴포넌트인데 이는 서비스 애너테이션을 내부 구조를 확인 하면 컴포넌트가 등록되어 있는 것을 알 수 있다. 이로 인해 클래스에 붙이는 `@Service, @RestController 등`은 모두 컴포넌트가 디폴트로 등록이 되어있어 서비스, 컨트롤러 등의 애너테이션을 사용하면 자동으로 Bean에 등록이 된다.